--type record 

DECLARE
TYPE EMP_REC IS RECORD(
V_NAME EMPLOYEES.FIRST_NAME%TYPE,
V_SALARY EMPLOYEES.SALARY%TYPE
);

V_EMP_REC EMP_REC;
BEGIN
  SELECT LAST_NAME,SALARY INTO V_EMP_REC FROM EMPLOYEES E WHERE E.EMPLOYEE_ID = 100;
  DBMS_OUTPUT.put_line(V_EMP_REC.V_NAME||','||V_EMP_REC.V_SALARY);

END;
/

-- rowtype


DECLARE
V_EMP_REC employees%rowtype;
BEGIN
  SELECT * INTO V_EMP_REC FROM EMPLOYEES E WHERE E.EMPLOYEE_ID = 100;
  DBMS_OUTPUT.put_line(V_EMP_REC.last_name||','||V_EMP_REC.salary);

END;
/

--要求: 查询出 150号 员工的工资, 若其工资大于或等于 10000 则打印 'salary >= 10000'; 
--若在 5000 到 10000 之间, 则打印 '5000<= salary < 10000'; 否则打印 'salary < 5000'

DECLARE 
V_SALARY EMPLOYEES.Salary%type;
BEGIN
  SELECT SALARY INTO V_SALARY FROM EMPLOYEES WHERE EMPLOYEE_ID = 150;
  IF V_SALARY >= 10000 
  THEN DBMS_OUTPUT.put_line('salary >= 10000');
  ELSIF V_SALARY >= 5000 AND V_SALARY <10000
  THEN DBMS_OUTPUT.put_line('5000<= salary < 10000');
  ELSE DBMS_OUTPUT.put_line('5000<= salary < 5000') ;        
  END IF;
  

END;
/


DECLARE 
V_SALARY EMPLOYEES.SALARY%TYPE;
V_TEMP VARCHAR2(100);

BEGIN
  SELECT SALARY INTO V_SALARY FROM EMPLOYEES WHERE EMPLOYEE_ID = 150;
  V_TEMP := 
  CASE 
  WHEN V_SALARY >= 10000  THEN  'salary >= 10000'
  WHEN V_SALARY >= 5000 THEN '5000<= salary < 10000'
  ELSE '5000<= salary < 5000'
  END;
  
  DBMS_OUTPUT.put_line(V_TEMP); 

END; 

/*
查询出 122 号员工的 JOB_ID, 若其值为 'IT_PROG', 则打印 'GRADE: A'; 
              'AC_MGT', 打印 'GRADE B', 
              'AC_ACCOUNT', 打印 'GRADE C'; 
              否则打印 'GRADE D'
*/

DECLARE
V_JOB_ID EMPLOYEES.JOB_ID%TYPE;
V_TEMP VARCHAR2(100);
BEGIN 
  SELECT JOB_ID INTO V_JOB_ID FROM EMPLOYEES WHERE EMPLOYEE_ID = 122;
  V_TEMP :=
  CASE V_JOB_ID
       WHEN 'IT_PROG' THEN 'GRADE: A'
       WHEN 'AC_MGT' THEN 'GRADE B'
       WHEN 'AC_ACCOUNT' THEN 'GRADE C'
       ELSE 'GRADE D' 
  END;
  DBMS_OUTPUT.put_line(V_TEMP);
    

END;

--9. 使用循环语句打印 1 - 100.（三种方式）

DECLARE
V_INT NUMBER(10):=1;

BEGIN 
  LOOP
      DBMS_OUTPUT.put_line(V_INT||' ');
      V_INT := V_INT+1;
  EXIT WHEN V_INT >100;
  END LOOP;        
  

END;
/


DECLARE
V_INT NUMBER(10):=0;

BEGIN 
  WHILE V_INT < 100 LOOP
     V_INT := V_INT+1;
    DBMS_OUTPUT.put_line(V_INT||' ');   
  END LOOP;  
END;
/


DECLARE
BEGIN 
 FOR INT IN 1..100 LOOP
    DBMS_OUTPUT.put_line(INT||' ');   
 END LOOP;
END;          

--10. 综合使用 if, while 语句, 打印 1 - 100 之间的所有素数
--(素数: 有且仅用两个正约数的整数, 2, 3, 5, 7, 11, 13, ...).

DECLARE
BEGIN
  Dbms_Output.put_line(TRUNC(SQRT(6))||' '||MOD(6,2));
END;



DECLARE 
V_NUM NUMBER(3):=1;
V_K NUMBER(2) :=0;
V_TEMP NUMBER(3):=0;
V_INT NUMBER(2);
V_IS_PRIME BOOLEAN;
BEGIN 
  WHILE V_NUM < 100 LOOP
    V_IS_PRIME := FALSE;
    V_K := TRUNC(SQRT(V_NUM));
    V_INT:= 2;
    IF V_K < 2 
    THEN  V_TEMP := V_NUM; DBMS_OUTPUT.put_line(V_TEMP); 
    ELSE
      
      WHILE V_INT <= V_K LOOP
        
        IF MOD(V_NUM,V_INT) = 0 THEN          
           V_IS_PRIME := TRUE; 
        END IF;
        V_INT := V_INT+1;          
      END LOOP;
     -- DBMS_OUTPUT.put_line(V_NUM||' '||BOOLEAN_TO_CHAR(V_IS_PRIME)); 
      IF NOT V_IS_PRIME THEN       
        V_TEMP := V_NUM;
        DBMS_OUTPUT.put_line(V_TEMP); 
      END IF;  
    END IF;  
   
    V_NUM := V_NUM+1;
  END LOOP;

END;
/


DECLARE
V_FLAG BOOLEAN;
V_K NUMBER(2);
V_J NUMBER(2);
BEGIN
  FOR I IN 1..100 LOOP
    V_FLAG := FALSE;
    V_K := TRUNC(SQRT(I));
    V_J := 2;
    WHILE V_J <= V_K LOOP
      IF MOD(I,V_J) = 0 THEN
        V_FLAG := TRUE;
      END IF;  
    V_J := V_J+1;
    END LOOP;
    
    IF NOT V_FLAG THEN
      DBMS_OUTPUT.put_line(I);    
    END IF;      
  END LOOP; 


END;

--11+.打印1――100的自然数，当打印到50时，跳出循环，输出“打印结束”
DECLARE
BEGIN
  FOR I IN 1..100 LOOP
    DBMS_OUTPUT.put_line(I);
    IF I = 50 THEN
     GOTO L_COUNT50;
    END IF;  
  
  END LOOP;
  <<L_COUNT50>>
  DBMS_OUTPUT.PUT_LINE('PRINTING END');
END;


DECLARE
BEGIN
  FOR I IN REVERSE 1..100 LOOP
    DBMS_OUTPUT.put_line(I);
    IF I = 50 THEN
      DBMS_OUTPUT.PUT_LINE('PRINTING END');
      EXIT;
    END IF;    
  END LOOP;
 DBMS_OUTPUT.PUT_LINE('HELLO');
END;


DECLARE
V_J NUMBER(3);
BEGIN 
  FOR I IN REVERSE 1..5 LOOP
    V_J := I;
    FOR J IN 1..V_J LOOP
      DBMS_OUTPUT.PUT_LINE('J: '||J);
      IF J = 3 THEN
        EXIT;
      END IF;  
    END LOOP;
    DBMS_OUTPUT.put_line('I: '||I);
  END LOOP;
END;
/





--要求: 打印出 80 部门的所有的员工的工资:salary: xxx

-- WITH CURSOR 
DECLARE
V_EMP_REC EMPLOYEES%ROWTYPE;
CURSOR EMP_CURSOR IS SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = 80 ORDER BY EMPLOYEE_ID;
BEGIN 
/*  OPEN EMP_CURSOR;
  FETCH EMP_CURSOR INTO V_EMP_REC;
  WHILE EMP_CURSOR%FOUND LOOP
    DBMS_OUTPUT.put_line( V_EMP_REC.LAST_NAME ||'''S SALARY IS '||V_EMP_REC.SALARY||' '||EMP_CURSOR%ROWCOUNT);
    FETCH EMP_CURSOR INTO V_EMP_REC;
  END LOOP; 
  CLOSE EMP_CURSOR;*/
  
  FOR E IN EMP_CURSOR LOOP
    DBMS_OUTPUT.put_line( E.LAST_NAME ||'''S SALARY IS '||E.SALARY||' '||EMP_CURSOR%ROWCOUNT); 
  END LOOP;
END;
/

-- WITHOUT CURSOR
DECLARE
BEGIN 
  FOR T IN (SELECT * FROM EMPLOYEES E WHERE E.DEPARTMENT_ID = 80) LOOP
    DBMS_OUTPUT.put_line(T.LAST_NAME||'''S SALARY IS '||T.SALARY);
  END LOOP;

END;

--13. 使用游标的练习: 
--打印出 manager_id 为 100 的员工的 last_name, email, salary 信息(使用游标, 记录类型)
DECLARE
CURSOR MANAGER_CURSOR IS SELECT LAST_NAME, EMAIL,SALARY FROM EMPLOYEES WHERE MANAGER_ID = 100;
BEGIN
  FOR M IN MANAGER_CURSOR LOOP
    DBMS_OUTPUT.PUT_LINE(M.LAST_NAME||' '||M.EMAIL||' '||M.SALARY);
  END LOOP; 
END;

DECLARE
BEGIN
  FOR M IN (SELECT LAST_NAME, EMAIL, SALARY FROM EMPLOYEES WHERE MANAGER_ID = 100) LOOP
    DBMS_OUTPUT.PUT_LINE(M.LAST_NAME||' '||M.EMAIL||' '||M.SALARY);
  END LOOP;
END; 

--SELECT E.*,E.ROWID FROM EMPLOYEES E 
--查询前 10 名员工的信息.

DECLARE
BEGIN
  FOR E IN (SELECT * FROM (SELECT * FROM EMPLOYEES ORDER BY SALARY DESC) ESAL WHERE ROWNUM <=10)LOOP
    DBMS_OUTPUT.put_line(E.EMPLOYEE_ID||E.FIRST_NAME||E.LAST_NAME);
    
  END LOOP;

END;
--14. 利用游标, 调整公司中员工的工资: 
/*
工资范围       调整基数
    0 - 5000       5%
    5000 - 10000   3%
    10000 - 15000  2%
    15000 -        1%
*/

DECLARE
CURSOR EMP_CURSOR IS SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES;
V_EMPID EMPLOYEES.EMPLOYEE_ID%TYPE;
V_SALARY EMPLOYEES.SALARY%TYPE; 
BEGIN 
  FOR SAL IN EMP_CURSOR LOOP
    V_EMPID:= SAL.EMPLOYEE_ID;
    V_SALARY:= V_SAL;
    DBMS_OUTPUT.put_line ('EMP_ID '||V_EMPID||' OLD SALARY '|| V_SALARY);
    IF V_SALARY <= 5000 THEN
      V_SALARY := V_SALARY*1.05;
    ELSIF V_SALARY <= 10000 THEN
      V_SALARY := V_SALARY * 1.03;
    ELSIF V_SALARY <= 15000 THEN
      V_SALARY := V_SALARY * 1.02;
    ELSIF  V_SALARY > 15000 THEN
      V_SALARY := V_SALARY * 1.01;
    END IF;
     DBMS_OUTPUT.put_line ('EMP_ID '||V_EMPID||' NEW SALARY '|| V_SALARY);
    UPDATE EMPLOYEES E SET E.SALARY = V_SALARY WHERE E.EMPLOYEE_ID = V_EMPID;
    IF EMP_CURSOR%ROWCOUNT = 10 THEN 
      EXIT;
    END IF;   
  END LOOP;

END;

-- 16 CURSOR PARAMETER
DECLARE
CURSOR EMP_CURSOR(P_EMPID EMPLOYEES.EMPLOYEE_ID%TYPE) IS 
SELECT EMPLOYEE_ID,SALARY FROM EMPLOYEES WHERE EMPLOYEE_ID = P_EMPID;

V_EMPID EMPLOYEES.EMPLOYEE_ID%TYPE := &EMPID;
V_PER NUMBER(3,2);
BEGIN
  FOR SAL IN EMP_CURSOR(P_EMPID =>V_EMPID) LOOP
      IF  V_SAL <= 5000 THEN
         V_PER:=1.05;
      ELSIF  V_SAL <= 10000 THEN
         V_PER:=1.03;
      ELSIF  V_SAL <= 15000 THEN
         V_PER:=1.02;
      ELSIF  V_SAL > 15000 THEN
         V_PER:=1.01;
    END IF;  
    DBMS_OUTPUT.put_line ('update employee_id  '||SAL.EMPLOYEE_ID||'SALARY from'||V_SAL||'to '|| V_SAL*v_per);  
    UPDATE EMPLOYEES E SET E.SALARY = V_SAL*v_per WHERE E.EMPLOYEE_ID = SAL.EMPLOYEE_ID;

  END LOOP;

END;

select MAX(E.EMPLOYEE_ID) from employees e where e.employee_id = 103;
/
DECLARE
V_EMPID EMPLOYEES.EMPLOYEE_ID%TYPE := &EMPID;
V_PER NUMBER(3,2);
BEGIN
   

  FOR SAL IN (select employee_id,salary from employees where employee_id = v_empid) LOOP
       
        
      IF  V_SAL <= 5000 THEN
         V_PER:=1.05;
      ELSIF  V_SAL <= 10000 THEN
         V_PER:=1.03;
      ELSIF  V_SAL <= 15000 THEN
         V_PER:=1.02;
      ELSIF  V_SAL > 15000 THEN
         V_PER:=1.01;
    END IF;  
    DBMS_OUTPUT.put_line ('update employee_id  '||SAL.EMPLOYEE_ID||'SALARY from'||V_SAL||'to '|| V_SAL*v_per);  
    UPDATE EMPLOYEES E SET E.SALARY = V_SAL*v_per WHERE E.EMPLOYEE_ID = SAL.EMPLOYEE_ID;
    


  END LOOP;
  


END;
/
select * from employees e where e.employee_id = 103;


--17. 隐式游标: 更新指定员工 salary(涨工资 10)，如果该员工没有找到，则打印”查无此人” 信息


DECLARE
 V_EMPID EMPLOYEES.EMPLOYEE_ID%TYPE := TO_NUMBER(NVL('&EMPID','207'));     
BEGIN
  UPDATE EMPLOYEES E SET E.SALARY = E.SALARY*1.1 WHERE E.EMPLOYEE_ID = V_EMPID;
  IF SQL%NOTFOUND THEN
    DBMS_OUTPUT.PUT_LINE(V_EMPID||' IS NOT FOUND');
  END IF;

END;
/



-- 16 CURSOR PARAMETER
DECLARE
CURSOR EMP_CURSOR IS 
SELECT EMPLOYEE_ID,SALARY FROM EMPLOYEES where rownum <=5
FOR UPDATE OF SALARY NOWAIT;
V_SAL EMPLOYEES.SALARY%TYPE;
V_PER NUMBER(3,2);
BEGIN
  --OPEN EMP_CURSOR;
  FOR SAL IN EMP_CURSOR LOOP
      V_SAL:= SAL.SALARY;
      IF  V_SAL <= 5000 THEN
         V_PER:=1.05;
      ELSIF  V_SAL <= 10000 THEN
         V_PER:=1.03;
      ELSIF  V_SAL <= 15000 THEN
         V_PER:=1.02;
      ELSIF  V_SAL > 15000 THEN
         V_PER:=1.01;
    END IF;  
    DBMS_OUTPUT.put_line ('update employee_id  '||SAL.EMPLOYEE_ID||'SALARY from'||V_SAL||'to '|| V_SAL*v_per);  
    UPDATE EMPLOYEES E SET E.SALARY = V_SAL*v_per WHERE CURRENT OF EMP_CURSOR; 

  END LOOP;
 --  CLOSE EMP_CURSOR;
END;
--表中查询某部门的员工情况，将其资最低定为 3000
DECLARE
 CURSOR EMP_CURSOR(P_DPT_ID EMPLOYEES.DEPARTMENT_ID%TYPE) IS 
 SELECT EE.EMPLOYEE_ID FROM EMPLOYEES EE WHERE EE.SALARY = 
 (SELECT MIN(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = P_DPT_ID)
 FOR UPDATE OF SALARY NOWAIT;
 
 V_DEPT_ID EMPLOYEES.DEPARTMENT_ID%TYPE := &DPT_ID;
  
BEGIN 
  FOR DEPT IN EMP_CURSOR(P_DPT_ID=>V_DEPT_ID) LOOP
    UPDATE EMPLOYEES E SET E.SALARY = 3000,E.COMMISSION_PCT= 0.15 WHERE CURRENT OF EMP_CURSOR;
    DBMS_OUTPUT.put_line(DEPT.EMPLOYEE_ID ||'''S SAL HAS BEEN UPDATED TO 3000');
  END LOOP;

END;
/

SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = 80 ORDER BY SALARY; 



-- EXCEPTION
DECLARE
  V_EMPID EMPLOYEES.EMPLOYEE_ID%TYPE := &EMPID;
  V_SAL EMPLOYEES.SALARY%TYPE; 
BEGIN 
  SELECT SALARY INTO V_SAL FROM EMPLOYEES WHERE EMPLOYEE_ID = V_EMPID;
  DBMS_OUTPUT.put_LINE(V_SAL);
EXCEPTION
  WHEN NO_DATA_FOUND THEN 
     DBMS_OUTPUT.put_line(V_EMPID||' IS NOT EXISTING');
END; 

-- DELETE DUP RECORDS
DELETE FROM JH_DUP J1 WHERE J1.ROWID > (SELECT MIN(J2.ROWID) FROM JH_DUP J2 
WHERE J1.EMPLOYEE_ID = J2.EMPLOYEE_ID
AND J1.START_DATE = J2.START_DATE
AND J1.JOB_ID = J2.JOB_ID
AND J1.DEPARTMENT_ID = J2.DEPARTMENT_ID ); 

SELECT * FROM JOB_HISTORY;

SELECT COUNT(J.EMPLOYEE_ID),J.EMPLOYEE_ID,J.JOB_ID FROM  JH_DUP J
GROUP BY J.EMPLOYEE_ID,J.START_DATE,J.END_DATE,J.JOB_ID,J.DEPARTMENT_ID; 

--19. 更新指定员工END DATE IF END_DATE < TO_DATE('2019','YYYY') ADD 1 YEAR；对 NO_DATA_FOUND 异常, TOO_MANY_ROWS 进行处理.
DECLARE
V_EMPID EMPLOYEES.EMPLOYEE_ID%TYPE := &EMPID;
V_END_DATE DATE;
BEGIN
  SELECT END_DATE INTO V_END_DATE FROM JOB_HISTORY JH WHERE JH.EMPLOYEE_ID = V_EMPID;
  IF V_END_DATE < TO_DATE('2019','YYYY') THEN
    V_END_DATE := ADD_MONTHS(V_END_DATE,12);
  END IF;
  UPDATE JOB_HISTORY JH SET JH.END_DATE = V_END_DATE WHERE JH.EMPLOYEE_ID = V_EMPID;
EXCEPTION
WHEN NO_DATA_FOUND THEN 
  DBMS_OUTPUT.put_line('THE EMPLOYEE '||V_EMPID||' IS NOT EXISTING IN JOB_HISTORY');
  DBMS_OUTPUT.put_line(DBMS_UTILITY.format_error_stack||' '||DBMS_UTILITY.format_error_backtrace);    

WHEN TOO_MANY_ROWS THEN 
  DBMS_OUTPUT.PUT_LINE(V_EMPID||' RETURNS MULTIPLE ROWS');
  DBMS_OUTPUT.put_line(DBMS_UTILITY.format_error_stack||' '||DBMS_UTILITY.format_error_backtrace);    


END;
/

SELECT * FROM DEPARTMENTS D;


DECLARE
V_DEPT_ID EMPLOYEES.DEPARTMENT_ID%TYPE := &DEPT_ID;
DEPT_REMAINING EXCEPTION;
PRAGMA EXCEPTION_INIT(DEPT_REMAINING,-2292);
BEGIN
  DELETE FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = V_DEPT_ID;
  IF SQL%NOTFOUND THEN
    DBMS_OUTPUT.put_line(V_DEPT_ID||' IS NOT EXISTING');
  END IF;
EXCEPTION
  WHEN DEPT_REMAINING THEN
    DBMS_OUTPUT.put_line(V_DEPT_ID||' STILL HAS EMPLOYEES!');
    DBMS_OUTPUT.put_line(DBMS_UTILITY.format_error_stack||' '||DBMS_UTILITY.format_error_backtrace);    
  WHEN OTHERS THEN
    DBMS_OUTPUT.put_line(DBMS_UTILITY.format_error_stack||' '||DBMS_UTILITY.format_error_backtrace);  

END;
/

-- ERROR LOG P1

BEGIN
    DBMS_ERRLOG.create_error_log(dml_table_name => 'JOB_HISTORY',err_log_table_name => 'ERROR_JOB_HISOTRY');

END;

INSERT INTO JOB_HISTORY(EMPLOYEE_ID,
                        START_DATE,
                        END_DATE,
                        JOB_ID,
                        DEPARTMENT_ID)
            VALUES (888,'2354',SYSDATE,'1BC',80)            
  LOG ERRORS INTO ERROR_JOB_HISOTRY REJECT LIMIT UNLIMITED;   


SELECT *FROM ERROR_JOB_HISOTRY;

-- CREATE ERROR TABLE
CREATE TABLE ERROR_LOGS(
  USER_NAME VARCHAR(255),
  ERROR_DATE DATE,
  ERROR_CODE NUMBER(10),
  ERROR_MESSAGE VARCHAR(255),
  ERROR_DETAILS CLOB
);

-- REWRITE WITH ERROR HANDLING
DECLARE
V_DEPT_ID EMPLOYEES.DEPARTMENT_ID%TYPE := &DEPT_ID;
DEPT_REMAINING EXCEPTION;
PRAGMA EXCEPTION_INIT(DEPT_REMAINING,-2292);
V_ERRNO ERROR_LOGS.ERROR_CODE%TYPE;
V_ERRMSG ERROR_LOGS.ERROR_MESSAGE%TYPE;
V_ERR_DETAIL ERROR_LOGS.ERROR_DETAILS%TYPE;
BEGIN
  DELETE FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = V_DEPT_ID;
  IF SQL%NOTFOUND THEN
    DBMS_OUTPUT.put_line(V_DEPT_ID||' IS NOT EXISTING');
  END IF;
EXCEPTION
  WHEN DEPT_REMAINING THEN
    V_ERR_DETAIL := V_DEPT_ID||' STILL HAS EMPLOYEES!';
    V_ERRNO := SQLCODE;
    V_ERRMSG := SQLERRM;
    INSERT INTO ERROR_LOGS(USER_NAME,ERROR_DATE,ERROR_CODE,ERROR_MESSAGE,ERROR_DETAILS)
    VALUES (USER,SYSDATE,V_ERRNO,V_ERRMSG,V_ERR_DETAIL); 
  WHEN OTHERS THEN
    V_ERRNO := SQLCODE;
    V_ERRMSG := SQLERRM;
    INSERT INTO ERROR_LOGS(USER_NAME,ERROR_DATE,ERROR_CODE,ERROR_MESSAGE)
    VALUES (USER,SYSDATE,V_ERRNO,V_ERRMSG); 

END;
/


SELECT * FROM ERROR_LOGS; 

-- REWRITE WITH LOOP



-- ONCE ERROR OCCURS THE LOOP WILL BE INTERRUPTED
DECLARE
V_DEPT_ID DEPARTMENTS.DEPARTMENT_ID%TYPE;
DEPT_REMAINING EXCEPTION;
PRAGMA EXCEPTION_INIT(DEPT_REMAINING,-2292);
V_ERRNO ERROR_LOGS.ERROR_CODE%TYPE;
V_ERRMSG ERROR_LOGS.ERROR_MESSAGE%TYPE;
V_ERR_DETAIL ERROR_LOGS.ERROR_DETAILS%TYPE;
BEGIN
  
 FOR DEPT IN (SELECT * FROM DEPARTMENTS)LOOP
   V_DEPT_ID:=  DEPT.DEPARTMENT_ID;
   DELETE FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = V_DEPT_ID
   LOG ERRORS INTO ERR_DEPT REJECT LIMIT UNLIMITED;
 END LOOP;
  
  
EXCEPTION
  WHEN DEPT_REMAINING THEN
    V_ERR_DETAIL := V_DEPT_ID||' STILL HAS EMPLOYEES!';
    V_ERRNO := SQLCODE;
    V_ERRMSG := SQLERRM;
    INSERT INTO ERROR_LOGS(USER_NAME,ERROR_DATE,ERROR_CODE,ERROR_MESSAGE,ERROR_DETAILS)
    VALUES (USER,SYSDATE,V_ERRNO,V_ERRMSG,V_ERR_DETAIL); 
  WHEN OTHERS THEN
    V_ERRNO := SQLCODE;
    V_ERRMSG := SQLERRM;
    INSERT INTO ERROR_LOGS(USER_NAME,ERROR_DATE,ERROR_CODE,ERROR_MESSAGE)
    VALUES (USER,SYSDATE,V_ERRNO,V_ERRMSG); 

END;
/



BEGIN
  DBMS_ERRLOG.create_error_log(dml_table_name => 'DEPARTMENTS',err_log_table_name => 'ERR_DEPT');

END;

DECLARE
  V_DEPT_ID DEPARTMENTS.DEPARTMENT_ID%TYPE;

BEGIN 
  FOR DEPT IN (SELECT * FROM DEPARTMENTS)LOOP
    V_DEPT_ID:=  DEPT.DEPARTMENT_ID;
    DELETE FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = V_DEPT_ID
    LOG ERRORS INTO ERR_DEPT REJECT LIMIT UNLIMITED;
  END LOOP;
  
END;

SELECT *FROM DEPARTMENTS; 
SELECT * FROM ERR_DEPT;

SELECT *FROM ERROR_LOGS；



-- update the salary of an given employee, raise exception when the employee is not existing

DECLARE
E_INVALID_EMPID EXCEPTION;
V_EMPID EMPLOYEES.Employee_Id%type;
BEGIN

  V_EMPID:=&EMPID;
  IF REGEXP_LIKE(V_EMPID, '^[0-9]+$') THEN
    V_EMPID := TO_NUMBER(V_EMPID);
  ELSE
    RAISE VALUE_ERROR;
  END IF;
  UPDATE EMPLOYEES E SET E.SALARY = E.SALARY+100 WHERE E.EMPLOYEE_ID = V_EMPID;
  
  
  IF SQL%NOTFOUND THEN
    RAISE E_INVALID_EMPID;
  END IF;
EXCEPTION
  WHEN E_INVALID_EMPID  THEN
      DBMS_OUTPUT.put_line(V_EMPID ||' IS NOT EXISTING!');
  WHEN VALUE_ERROR THEN 
      DBMS_OUTPUT.put_line(DBMS_UTILITY.format_error_stack||' '||DBMS_UTILITY.format_error_backtrace); 
     -- RAISE; 

END;



DECLARE
E_INVALID_EMPID EXCEPTION;
V_EMPID EMPLOYEES.Employee_Id%type := &EMPID;
PRAGMA EXCEPTION_INIT(E_INVALID_EMPID,-20899);
BEGIN
  UPDATE EMPLOYEES E SET E.SALARY = E.SALARY+100 WHERE E.EMPLOYEE_ID = V_EMPID;
  IF SQL%NOTFOUND THEN
    RAISE E_INVALID_EMPID;
  END IF;
EXCEPTION
  WHEN E_INVALID_EMPID  THEN
     RAISE_APPLICATION_ERROR(-20899,V_EMPID||' IS NOT EXISTING');
END;

--22.1 函数的 helloworld: 返回一个 "helloworld" 的字符串 V
CREATE OR REPLACE FUNCTION helloWorld
RETURN VARCHAR2
IS
BEGIN
  RETURN 'HELLO WORLD!';
END;
/


BEGIN
  DBMS_OUTPUT.put_line(helloWorld);

END;          



CREATE OR REPLACE FUNCTION helloWorld (P_STR IN VARCHAR2 DEFAULT 'HELLO WORLD')
RETURN VARCHAR2
IS
BEGIN
  RETURN P_STR;
END;
/

BEGIN
  DBMS_OUTPUT.put_line(helloWorld());

END;

--22.3 创建一个存储函数，返回当前的系统时间
CREATE OR REPLACE FUNCTION RETURN_CURRENT_TIME
RETURN DATE
IS
BEGIN
  RETURN SYSDATE;
END;

SELECT RETURN_CURRENT_TIME FROM DUAL;
--23. 定义带参数的函数: 两个数相加
CREATE OR REPLACE FUNCTION TWO_SUM(P_NUM1 IN NUMBER, P_NUM2 IN NUMBER )
RETURN NUMBER
IS
V_NUM NUMBER := 0;
BEGIN
  V_NUM := P_NUM1 + P_NUM2;
  RETURN V_NUM;
END;


SELECT TWO_SUM(P_NUM1 => 5,P_NUM2 => 6) FROM DUAL; 
--定义一个函数: 获取给定部门的工资总和, 要求:部门号定义为参数, 工资总额定义为返回值.
CREATE OR REPLACE FUNCTION SUM_SALARY(P_DEPTID IN DEPARTMENTS.DEPARTMENT_ID%TYPE)
RETURN EMPLOYEES.SALARY%TYPE
IS
V_SAL EMPLOYEES.SALARY%TYPE;
E_INVALID_DEPTID EXCEPTION;
BEGIN
  SELECT SUM(SALARY) INTO V_SAL FROM EMPLOYEES WHERE DEPARTMENT_ID = P_DEPTID;
  IF V_SAL IS NULL THEN
    RAISE E_INVALID_DEPTID;   
   END IF;  
  RETURN V_SAL; 
EXCEPTION
  WHEN E_INVALID_DEPTID THEN
    DBMS_OUTPUT.put_line(P_DEPTID || ' IS NOT A VALID DEPARTMENT ID.');
    DBMS_OUTPUT.put_line(DBMS_UTILITY.format_error_backtrace);
    RETURN -1;
END;
/
 
BEGIN
  DBMS_OUTPUT.put_line(SUM_SALARY(888));

END;
/

SELECT SUM_SALARY(888) FROM DUAL; 


--要求: 定义一个函数: 获取给定部门的工资总和 和 该部门的员工总数(定义为 OUT 类型的参数).
--要求: 部门号定义为参数, 工资总额定义为返回值.


CREATE OR REPLACE FUNCTION DEPT_SUMSAL_AND_SUMEMP(P_DEPTID IN EMPLOYEES.DEPARTMENT_ID%TYPE, P_EMP_SUM OUT NUMBERS DEFAULT 0)
RETURN EMPLOYEES.SALARY%TYPE
IS
V_SAL EMPLOYEES.SALARY%TYPE;
E_INVALID_DEPTID EXCEPTION;

BEGIN
  SELECT SUM(SALARY), COUNT(EMPLOYEE_ID) INTO V_SAL,P_EMP_SUM FROM EMPLOYEES WHERE DEPARTMENT_ID = P_DEPTID;
  IF V_SAL IS NULL THEN
    RAISE E_INVALID_DEPTID;   
   END IF;  
  RETURN V_SAL; 
EXCEPTION
  WHEN E_INVALID_DEPTID THEN
    DBMS_OUTPUT.put_line(P_DEPTID || ' IS NOT A VALID DEPARTMENT ID.');
    DBMS_OUTPUT.put_line(DBMS_UTILITY.format_error_backtrace);
    RETURN -1;
END;
/

DECLARE
V_EMP_SUM NUMBER;
V_SAL EMPLOYEES.SALARY%TYPE;
BEGIN
  V_SAL:=HR.DEPT_SUMSAL_AND_SUMEMP(P_DEPTID=>80,P_EMP_SUM =>V_EMP_SUM );
  DBMS_OUTPUT.put_line(V_SAL||' '||V_EMP_SUM);
END;
/



-- 26*. 定义一个存储过程: 获取给定部门的工资总和(通过 out 参数), 要求:部门号和工资总额定义为参数

CREATE OR REPLACE PROCEDURE GIVING_SUM_SAL(P_DEPTID IN NUMBER, P_SUM_SAL OUT NUMBER)
IS
V_SAL NUMBER; 
BEGIN 
  SELECT SUM(SALARY) INTO V_SAL FROM EMPLOYEES WHERE DEPARTMENT_ID = P_DEPTID;
  P_SUM_SAL := V_SAL; 
END;
/

DECLARE
V_SAL NUMBER;
BEGIN
  HR.GIVING_SUM_SAL(P_DEPTID => 80,P_SUM_SAL => V_SAL);
  DBMS_OUTPUT.put_line(V_SAL);
END;

/*
27*. 自定义一个存储过程完成以下操作: 
对给定部门(作为输入参数)的员工进行加薪操作, 若其到公司的时间在 (? , 95) 期间,    为其加薪 %5
                                                               [95 , 98)             %3       
                                                               [98, ?)               %1
得到以下返回结果: 为此次加薪公司每月需要额外付出多少成本(定义一个 OUT 型的输出参数).
*/



CREATE OR REPLACE PROCEDURE ADJUST_SALARY(P_DEPTID IN NUMBER, 
                                          P_ADJUST_MONEY OUT NUMBER)
IS
V_HIRE_DATE DATE;
V_MONEY EMPLOYEES.SALARY%TYPE := 0;
V_PER NUMBER (2,2);
V_SAL EMPLOYEES.SALARY%TYPE;
E_INVLIAD_DEPTID EXCEPTION;
BEGIN
  FOR EMP IN (SELECT SALARY,HIRE_DATE, EMPLOYEE_ID FROM EMPLOYEES WHERE DEPARTMENT_ID = P_DEPTID)LOOP
    V_HIRE_DATE := EMP.HIRE_DATE;
    V_SAL := EMP.SALARY;
    IF V_HIRE_DATE <= TO_DATE('2003','YYYY') THEN
      V_PER := 0.05;
    ELSIF V_HIRE_DATE <= TO_DATE('2005','YYYY') THEN
      V_PER := 0.03;
    ELSIF V_HIRE_DATE > TO_DATE('2005','YYYY') THEN
      V_PER := 0.01;
    END IF;  
         
    V_MONEY := V_MONEY + V_SAL*V_PER;
    UPDATE EMPLOYEES E SET E.SALARY = V_SAL*(1+V_PER) WHERE E.EMPLOYEE_ID = EMP.EMPLOYEE_ID;
  END LOOP;
  
  P_ADJUST_MONEY := V_MONEY;
  IF V_HIRE_DATE IS NULL THEN
    RAISE E_INVLIAD_DEPTID;
  END IF;
EXCEPTION  
  WHEN E_INVLIAD_DEPTID THEN
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE(P_DEPTID ||' IS INVALID');
  
END;
/

DECLARE
V_MONEY NUMBER;

BEGIN
  HR.ADJUST_SALARY(P_DEPTID =>80,P_ADJUST_MONEY =>V_MONEY);
  DBMS_OUTPUT.put_line(V_MONEY); 
END;
/


SELECT COUNT(*),DEPARTMENT_ID FROM EMPLOYEES GROUP BY DEPARTMENT_ID;
SELECT E.*,E.ROWID FROM EMPLOYEES E WHERE DEPARTMENT_ID = 80; 

CREATE OR REPLACE PROCEDURE DELETE_EMPLOYEES(P_EMPID IN EMPLOYEES.EMPLOYEE_ID%TYPE)
IS
TYPE EmpRec IS RECORD (last_name  employees.last_name%TYPE, 
                       salary     employees.salary%TYPE);
E_EMP_NOTFOUND EXCEPTION;
V_EMP_HIST EmpRec;
BEGIN
  DELETE FROM EMPLOYEES E WHERE E.EMPLOYEE_ID = P_EMPID
  RETURNING LAST_NAME, SALARY INTO V_EMP_HIST;
  
  IF SQL%NOTFOUND THEN
    RAISE E_EMP_NOTFOUND;
  END IF;
  
  DBMS_OUTPUT.put_line('DELETED EMPLOYEE '||V_EMP_HIST.SALARY||' '||V_EMP_HIST.LAST_NAME);  
EXCEPTION 
  WHEN E_EMP_NOTFOUND THEN
    DBMS_OUTPUT.put_line(P_EMPID||' NOT FOUND');
  WHEN OTHERS THEN
    DBMS_OUTPUT.put_line(DBMS_UTILITY.format_error_stack||' '||DBMS_UTILITY.format_error_backtrace);   
END;
/
BEGIN
DELETE_EMPLOYEES(P_EMPID => 104);
END;
 --DELETE FROM EMPLOYEES E WHERE E.EMPLOYEE_ID = 101;
 
 SELECT * FROM EMPLOYEES E WHERE NOT EXISTS (SELECT 1 FROM JOB_HISTORY JH WHERE JH.EMPLOYEE_ID = E.EMPLOYEE_ID) 
                           AND NOT EXISTS (SELECT 1 FROM EMPLOYEES E2 WHERE E2.MANAGER_ID = E.EMPLOYEE_ID);
SELECT * FROM EMPLOYEES E WHERE E.EMPLOYEE_ID = 104;


CREATE OR REPLACE FUNCTION RETURN_EMP_ROW(P_EMPID IN EMPLOYEES.EMPLOYEE_ID%TYPE)
RETURN EMPLOYEES%ROWTYPE
IS
V_EMP EMPLOYEES%ROWTYPE;
BEGIN 
  SELECT * INTO V_EMP FROM EMPLOYEES WHERE EMPLOYEE_ID = P_EMPID;
  RETURN V_EMP; 

END;


DECLARE
V_EMP EMPLOYEES%ROWTYPE;
BEGIN 
  V_EMP := RETURN_EMP_ROW(101);
  DBMS_OUTPUT.put_line(V_EMP.SALARY);

END;



-- ACCOIATION ARRAY

DECLARE
 TYPE T_EMP_NAME IS TABLE OF NUMBER
 INDEX BY EMPLOYEES.LAST_NAME%TYPE; -- CAN ONLY BE VARCHAR2 DO NOT USE DATE
 
 V_emp_NAME T_EMP_NAME;
 D EMPLOYEES.LAST_NAME%TYPE; 

BEGIN 
  FOR EMP IN (SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID BETWEEN 101 AND 105)LOOP
    V_emp_NAME(EMP.LAST_NAME) := EMP.EMPLOYEE_ID; 
  END LOOP;
  
  D := V_emp_NAME.FIRST; 
  WHILE D IS NOT NULL LOOP
    DBMS_OUTPUT.put_line('EMPID OF '||D ||' IS '||V_emp_NAME(D));
    D := V_emp_NAME.NEXT(D); 
  END LOOP ;

END;
/

-- ARRAY CAN RETURN MUKLTIPLE ROWS


DECLARE
V_EMP_ARRAY TEST_UTILITY.T_EMP_SALARY;
BEGIN
 V_EMP_ARRAY := TEST_UTILITY.GET_EMP_SAL(80);
 DBMS_OUTPUT.put_line(V_EMP_ARRAY.FIRST);
END;


-- ROWTYPE AND TYPE RECORD CAN ONLY RETURN ONE ROW
DECLARE
 TYPE T_EMP_REC IS RECORD(
    EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE,
    LASTNAME EMPLOYEES.LAST_NAME%TYPE,
    SALARY EMPLOYEES.SALARY%TYPE 
 );
 
 V_EMP_REC T_EMP_REC;
BEGIN
  SELECT E.EMPLOYEE_ID,E.LAST_NAME,E.SALARY INTO V_EMP_REC FROM EMPLOYEES E WHERE E.EMPLOYEE_ID = 101;
  DBMS_OUTPUT.put_line(V_EMP_REC.EMP_ID||' ''S LAST NAME IS '||V_EMP_REC.LASTNAME||': SALARY: '||V_EMP_REC.SALARY);  
END;
/


DECLARE
TYPE A_EMP IS VARRAY(10) OF EMPLOYEES%ROWTYPE;
V_A_EMP A_EMP;
BEGIN 
SELECT * BULK COLLECT INTO V_A_EMP FROM EMPLOYEES WHERE ROWNUM <= 8; -- USE BULK COLLECT INTO ON COLLECTIONS
--V_A_EMP.TRIM(3); -- REMOVE LAST 3 ELEMENTS
V_A_EMP.EXTEND(1,3) ;   

DBMS_OUTPUT.PUT_LINE
        ('It has ' || V_A_EMP.COUNT || ' elements.');
DBMS_OUTPUT.PUT_LINE
        ('FIRST ' || V_A_EMP.FIRST || ' LAST '||V_A_EMP.LAST);  
        
  -- CANNOT USE EXISTS WITH ASSOCIATE ARRAY            
 DBMS_OUTPUT.put_line(BOOLEAN_TO_CHAR(V_A_EMP.EXISTS(10))); 
  DBMS_OUTPUT.put_line(BOOLEAN_TO_CHAR(V_A_EMP.EXISTS(5))); 
FOR I IN V_A_EMP.FIRST .. V_A_EMP.LAST LOOP
  DBMS_OUTPUT.put_line(V_A_EMP(I).LAST_NAME);

END LOOP;
      
END; 
/



DECLARE
   TYPE NumList IS TABLE OF NUMBER;
   n NumList := NumList(1966,1971,1984,1989,1999);
BEGIN
   DBMS_OUTPUT.PUT_LINE('The element after #2 is #' || N.NEXT(1)||' '||N.NEXT(1));
   DBMS_OUTPUT.PUT_LINE('The element before #2 is #' || n.PRIOR(1));
   n.DELETE(3);
     -- Delete an element to show how NEXT can handle gaps.
   DBMS_OUTPUT.PUT_LINE
     ('Now the element after #2 is #' || N(n.NEXT(2)));
   IF n.PRIOR(n.FIRST) IS NULL THEN
      DBMS_OUTPUT.PUT_LINE
        ('Can''t get PRIOR of the first element or NEXT of the last.');
   END IF;
END;
/


--一个helloworld级别的触发器

CREATE OR REPLACE TRIGGER HELLO_TRIGGER 
AFTER UPDATE ON EMPLOYEES
FOR EACH ROW
BEGIN
  
--dbms_output.put_line('hello...');
DBMS_OUTPUT.put_line('UPDATE EMPLOYEE '||:OLD.EMPLOYEE_ID||'''S SALARY FROM '||:OLD.SALARY||' TO '||:NEW.SALARY);
END;


UPDATE EMPLOYEES E SET E.SALARY=E.SALARY+100 WHERE E.EMPLOYEE_ID BETWEEN 101 AND 105;
 

--28. 触发器的 helloworld: 编写一个触发器, 在向 emp 表中插入记录时, 打印 'helloworld'

CREATE OR REPLACE TRIGGER AFTER_INSERT_EMP_TRIGGER
AFTER INSERT ON EMPLOYEES
FOR EACH ROW
BEGIN
  DBMS_OUTPUT.put_line('INSERT NEW REC '||:NEW.EMPLOYEE_ID);

END;

INSERT INTO EMPLOYEES SELECT EMPLOYEES_SEq.Nextval,
                      'test',
                      'test',
                      'test@gmail.com',
                      PHONE_NUMBER,
                      HIRE_DATE,
                      JOB_ID,
                      SALARY,
                      COMMISSION_PCT,
                      MANAGER_ID,
                      DEPARTMENT_ID from employees where employee_id = 101;


--31. 编写一个触发器, 在对 my_emp 记录进行删除的时候, 在 my_emp_bak 表中备份对应的记录
CREATE TABLE MY_EMP_BK
AS 
SELECT * FROM EMPLOYEES WHERE 1 =2;

ALTER TABLE MY_EMP_BK
ADD (ACTION_DATE DATE, ACTION_TYPE VARCHAR2(10));


CREATE OR REPLACE TRIGGER AFTER_DELETE_ON_EMPLOYEES
BEFORE DELETE ON EMPLOYEES
FOR EACH ROW
BEGIN
  INSERT INTO MY_EMP_BK VALUES (:OLD.EMPLOYEE_ID,
                        :OLD.FIRST_NAME,
                        :OLD.LAST_NAME,
                        :OLD.EMAIL,
                        :OLD.PHONE_NUMBER,
                        :OLD.HIRE_DATE,
                        :OLD.JOB_ID,
                        :OLD.SALARY,
                        :OLD.COMMISSION_PCT,
                        :OLD.MANAGER_ID,
                        :OLD.DEPARTMENT_ID,
                        SYSDATE,
                        'DELETE');
END;
/


BEGIN
  HR.DELETE_EMPLOYEES(104);

END;


SELECT * FROM MY_EMP_BK;


-- INSTEAD OF DELETE VIEW TRIGGER


CREATE OR REPLACE VIEW EMPLOYEE_DEPARTMENT_DETAIL
AS 
SELECT E.EMPLOYEE_ID, D.DEPARTMENT_ID,E.LAST_NAME,D.DEPARTMENT_NAME FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID;



CREATE OR REPLACE TRIGGER UPDATE_EMP_DEPT_VIEW
INSTEAD OF UPDATE ON EMPLOYEE_DEPARTMENT_DETAIL
FOR EACH ROW
BEGIN
  IF :OLD.LAST_NAME != :NEW.LAST_NAME THEN
    UPDATE EMPLOYEES E SET E.LAST_NAME = :NEW.LAST_NAME WHERE E.EMPLOYEE_ID = :OLD.EMPLOYEE_ID;
  END IF;
  
   IF :OLD.DEPARTMENT_NAME != :NEW.DEPARTMENT_NAME THEN
    UPDATE DEPARTMENTS D SET D.DEPARTMENT_NAME = :NEW.DEPARTMENT_NAME WHERE D.DEPARTMENT_ID = :OLD.DEPARTMENT_ID; 
  END IF;
END;


SELECT * FROM EMPLOYEE_DEPARTMENT_DETAIL
SELECT * FROM EMPLOYEE_DEPARTMENT_DETAIL EDD WHERE EDD.EMPLOYEE_ID = 209

UPDATE EMPLOYEE_DEPARTMENT_DETAIL EDD SET EDD.DEPARTMENT_NAME = 'IT DEPT', EDD.LAST_NAME='OMG' WHERE EDD.DEPARTMENT_NAME ='IT' AND EDD.EMPLOYEE_ID = 106;
